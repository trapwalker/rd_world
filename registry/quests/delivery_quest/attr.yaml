__cls__: DeliveryQuest
_cls: DeliveryQuest
doc    : Примеры квестов

first_state: begin
current_state: ~

distance_table: reg:///registry/rpg_settings/disttable

caption: Доставка груза
#    text_short = StringField(tags='client', caption=u'Короткий текст квеста', doc=u'Может строиться и меняться по шаблону')
#    typename = StringField(tags='client', caption=u'Тип квеста', doc=u'Может быть произвольным')
#    list_icon = StringField(tags='client', caption=u'Пиктограмма для списков', doc=u'Мальенькая картинка для отображения в списках')  # todo: use UrlField
#    level = IntField(tags='client', caption=u'Уровень квеста', doc=u'Обычно число, но подлежит обсуждению')  # todo: обсудить
#    starttime = DateTimeField(tags='client', caption=u'Начало выполнения', doc=u'Время старта квеста')
#    deadline = DateTimeField(tags='client', caption=u'Срок выполнения этапа', doc=u'datetime до провала текущего этапа. Может меняться')

#    hirer = UniReferenceField(tags='client', caption=u'Заказчик', doc=u'NPC-заказчик квеста')
#    town = UniReferenceField(tags='client', caption=u'Город выдачи', doc=u'Город выдачи квеста')
#    agent = UniReferenceField(tags='client', caption=u'Агент', doc=u'Исполнитель квеста')

on_generate: |
    # todo: реализовать метод same_as для проверки похожести квестов
    for q in agent and agent.quests or []:
        if q.parent == quest.parent:
            if q.status is None:
                raise Cancel("QUEST CANCEL: You already have that unstarted quest: {q}")
            if q.status == 'active':
                raise Cancel("QUEST CANCEL: You already have more <<quest.active_count_max>> copies of that quest.")

    if not quest.recipient_list:
        raise Cancel("QUEST CANCEL: Empty recipient_list.")
    if not quest.delivery_set_list:
        raise Cancel("QUEST CANCEL: Empty empty delivery_set_list.")

    quest.recipient = random.choice(quest.recipient_list)
    quest.delivery_set = random.choice(quest.delivery_set_list)

    cost_delivery_items = 0
    for item in quest.delivery_set:
        cost_delivery_items += item.base_price * item.amount / item.stack_size

    if quest.recipient.hometown is None:
        raise Cancel("QUEST CANCEL: {} hometown is None.".format(quest.recipient.hometown))
    if quest.hirer.hometown is None:
        raise Cancel("QUEST CANCEL: {} hometown is None.".format(quest.hirer.hometown))

    distance = quest.hirer.hometown.distance_to(quest.recipient.hometown)
    distance_cost = round(distance / 100.)  # todo: уточнить стоимость 1px пути

    if distance_cost == 0:
        log('Delivery Quest: Warning!!! Distance from hirer<{}> to recipient<{}> = {}. Change recipient'.format(quest.hirer, quest.recipient, distance))

    quest.total_reward_money = quest.total_delivery_money_coef * cost_delivery_items + distance_cost
    quest.generate_reward()  # Устанавливаем награду за квест (карму, деньги и итемы)
    quest.init_text() # Инициализируем строку описания квеста

on_start: |
    if not quest.give_items(items=quest.delivery_set, event=event):
        quest.npc_replica(npc=quest.hirer, replica=u"Не хватает места в инвентаре.", event=event)
        log("DELIVERY QUEST: User have not enough empty slots")
        raise Cancel("QUEST CANCEL: User have not enough empty slot")

states:
    - id: begin
      parent: reg:///registry/quest_states/test/begin
      on_enter: |
          quest.delivery_note_uid = agent.add_note(
              quest_uid=quest.uid,
              note_class=NPCDeliveryNote,
              time=event.time,
              npc=quest.recipient,
              page_caption=quest.caption,
          )
          go('delivery')

    - id: delivery
      parent: reg:///registry/quest_states/test

      on_event: |
          if isinstance(event, OnNote):
              if (event.note_uid == quest.delivery_note_uid) and (event.result == True) and quest.take_items(items=quest.delivery_set, event=event):
                  agent.del_note(uid=quest.delivery_note_uid, time=event.time)
                  agent.set_relationship(time=event.time, npc=quest.hirer, dvalue=2)  # изменение отношения к нпц
                  go('reward')

    # todo: если будет ещё один квест с точно таким же состоянием, но отличающимся нпц, то вынести стейт отдельно и
    # просто его наследовать, при этом в on_generate прописывать поле reward_npc
    - id: reward
      parent: reg:///registry/quest_states/test

      on_enter: |
          quest.agent.set_balance(time=event.time, delta=quest.reward_money)
          quest.agent.set_karma(time=event.time, dvalue=quest.reward_karma)
          if len(quest.reward_items) > 0:
              quest.reward_note_uid = agent.add_note(
                  quest_uid=quest.uid,
                  note_class=NPCRewardItemsNote,
                  time=event.time,
                  npc=quest.recipient,
                  page_caption=u'Награда',
                  btn1_caption=u'<br>Забрать',
              )
          else:
              go('final')

      on_event: |
          if isinstance(event, OnNote):
              if (event.note_uid == quest.reward_note_uid) and (event.result == True):
                  if quest.give_items(items=quest.reward_items, event=event):
                      agent.del_note(uid=quest.reward_note_uid, time=event.time)
                      go('final')
                  else:
                      quest.npc_replica(npc=quest.hirer, replica=u"Не хватает места в инвентаре.", event=event)

    - id: final
      parent: reg:///registry/quest_states/final/win
